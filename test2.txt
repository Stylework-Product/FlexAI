import pandas as pd
from fastapi import FastAPI, Body, Depends, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MultiLabelBinarizer, MinMaxScaler
from fastapi.middleware.cors import CORSMiddleware
import re
import json
from typing import Optional, List
import os
import requests
from connection import ChatSession, create_new_session, get_existing_session
from datetime import datetime
from dotenv import load_dotenv

app = FastAPI(title="FlexAI", description="An AI-assistant for workspace booking")

app.add_middleware(
	CORSMiddleware,
	allow_origins=["*"],
	allow_credentials=True,
	allow_methods=["*"],
	allow_headers=["*"],
)

class UserInput(BaseModel):
	workspaceName: Optional[str] = ''
	city: str
	area: Optional[List[str]] = []  
	workspaceType: str
	size: Optional[int] = 1
	amenities: Optional[List[str]] = []
	bundle: Optional[List[str]] = []    
	budget: Optional[int] = 0
	rating: Optional[int] = 0
	offeringType: Optional[str] = ''

class ChatMessage(BaseModel):
	id: str
	text: str
	sender: str
	timestamp: str

class ChatRequest(BaseModel):
	user_message: str
	chat_history: List[ChatMessage]
	session_id: Optional[str] = None

global_sessions = {}

def get_session(session_id: str = None, user_id: str = None):
	if session_id:
		if session_id in global_sessions:
			session = global_sessions[session_id]
		else:
			session = get_existing_session(session_id)
			if session:
				global_sessions[session_id] = session
			else:
				# Do NOT create a new session if session_id is provided but not found
				return None
	else:
		session = ChatSession()
		global_sessions[session.session_id] = session

	if user_id and not session.user_id:
		session.user_id = user_id
		session.save_session() 

	return session

@app.get("/session/{session_id}")
async def get_session_data(session_id: str):
	"""Get session data by ID"""
	if session_id in global_sessions:
		return global_sessions[session_id].__dict__
	return {"error": "Session not found"}

@app.delete("/session/{session_id}")
async def delete_session(session_id: str):
	"""Delete a session"""
	if session_id in global_sessions:
		del global_sessions[session_id]
		return {"message": "Session deleted"}
	return {"error": "Session not found"}

class UserInfo(BaseModel):
	name: str
	email: str
	phone: str

class SessionRequest(BaseModel):
	user_info: UserInfo

@app.post("/session")
async def create_session(data: SessionRequest):
	user_info = data.user_info
	name = user_info.name.strip().lower().replace(" ", "_")
	email = user_info.email.strip().lower()
	user_id = f"{name}_{email}"
	session = create_new_session(user_id=user_id)
	
	print("[DEBUG] Created session:", session.session_id, "for user_id:", user_id)

	return {"session_id": session.session_id, "user_id": user_id}



df = pd.read_csv('final_dataset.csv')

def clean_amenity(a):
	return re.sub(r'[\[\]"\']', '', a).strip().lower()

df['Unboxed Coworking'] = df['Unboxed Coworking'].str.strip().str.lower()
df['CITY'] = df['CITY'].str.strip().str.lower()
df['STATUS'] = df['STATUS'].str.strip().str.lower()
df['CATEGORY AS PER PRICING'] = df['CATEGORY AS PER PRICING'].str.strip().str.lower()
df['CATEGORY AS PER SAP'] = df['CATEGORY AS PER SAP'].str.strip().str.lower()
if 'AREA' in df.columns:
	df['AREA'] = df['AREA'].str.strip().str.lower()

df['AMENITIES'] = df['AMENITIES'].apply(lambda x: [clean_amenity(s) for s in str(x).split(',')])

city_alias_map = {}
for city in df['CITY'].unique():
	city_alias_map[city] = city
	city_lower = city.strip().lower()
	# Only map well-known aliases, not substrings
	if city_lower == "delhi nct":
		city_alias_map["delhi"] = city
		city_alias_map["new delhi"] = city
	elif city_lower == "delhi":
		city_alias_map["new delhi"] = city
	if city_lower == "gurgaon":
		city_alias_map["gurugram"] = city
	if city_lower == "gurugram":
		city_alias_map["gurgaon"] = city
	if city_lower == "bengaluru":
		city_alias_map["bangalore"] = city
		city_alias_map["bangaluru"] = city
	if city_lower == "bangalore":
		city_alias_map["bengaluru"] = city
	if city_lower == "mumbai":
		city_alias_map["bombay"] = city
	if city_lower == "bombay":
		city_alias_map["mumbai"] = city
	if city_lower == "sahibzada ajit singh nagar (mohali)":
		city_alias_map["mohali"] = city
	if city_lower == "mysuru (mysore)":
		city_alias_map["mysore"] = city
		city_alias_map["mysuru"] = city
	if city_lower == "warangal (urban)":
		city_alias_map["warangal"] = city
	
load_dotenv()

GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
MAX_HISTORY_MESSAGES = int(os.getenv("MAX_HISTORY_MESSAGES"))
MIN_SIMILARITY_SCORE = float(os.getenv("MIN_SIMILARITY_SCORE"))

def check_if_user_wants_filters(user_message, chat_history):
	"""Check if user has requested filtering options"""
	filter_keywords = [
		'filter', 'sort', 'arrange', 'organize', 'show filters', 'filtering options',
		'sort by price', 'sort by rating', 'filter by location', 'filter by area',
		'cheapest', 'most expensive', 'highest rated', 'lowest rated',
		'price low to high', 'price high to low', 'rating high to low', 'rating low to high'
	]
	
	# Check current message
	user_message_lower = user_message.lower()
	if any(keyword in user_message_lower for keyword in filter_keywords):
		return True
	
	# Check recent chat history (last 3 messages)
	recent_messages = chat_history[-3:] if len(chat_history) > 3 else chat_history
	for msg in recent_messages:
		if msg.get('sender') == 'user':
			msg_text = msg.get('text', '').lower()
			if any(keyword in msg_text for keyword in filter_keywords):
				return True
	
	return False

@app.post("/gemini_chat")
def gemini_chat(
	user_message: str = Body(..., embed=True),
	chat_history: list = Body([], embed=True),
	session_id: Optional[str] = Body(None, embed=True),
	user_id: Optional[str] = Body(None, embed=True)
):
	result = []
	if len(chat_history) > MAX_HISTORY_MESSAGES:
		chat_history = chat_history[-MAX_HISTORY_MESSAGES:]

	if not GEMINI_API_KEY:
		return {"error": "Gemini API key not set."}

	session = get_session(session_id=session_id, user_id=user_id)
	session_id = session.session_id
	print(f"Session ID: {session_id}")

	session.add_user_message({
		"type": "user",
		"content": user_message,
	})
	
	url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent"
	headers = {"Content-Type": "application/json"}

	# Check if user wants filtering options
	user_wants_filters = check_if_user_wants_filters(user_message, chat_history)

	system_prompt = (
		"You are FlexiAI, a helpful assistant for a workspace booking platform called Styleworks. Your main job is to assist users in searching for and booking workspaces.\n"
		"Stylework is India's largest flexible workspace provider, offering a robust solution for businesses of various sizes. With a presence in 100+ cities in India, we connect individuals, startups, and enterprises to a diverse network of ready-to-move-in coworking and managed office spaces."
		"CRITICAL INSTRUCTIONS:\n"
		"1. DO NOT filter, search, or recommend any workspaces yourself\n"
		"2. DO NOT mention specific workspace names, addresses, or details\n"
		"3. DO NOT include any workspace recommendations in your response\n"
		"4. Your ONLY job is to:\n"
		"	- Have a friendly conversation with the user\n"
		"	- Answer users' questions about the platform and the recommendations provided (eg if they ask about what amenities are provided by a specific workspace or the price of a workspace you should be able to answer it based on the information provided)\n"
		"	- Extract search parameters from their message\n"
		"	- Let the recommendation engine handle ALL workspace suggestions\n"
		"	- Make sure user provides city and type of workspace they are looking for, if not provided in the start then ask them these questions one after another"
		"	- If the workspace type is not specified in the start but is mentioned later, update the search parameters accordingly but if it is specified in the start and not explicitly told to change later then keep it same.\n"
		"	- If the user specifies a workspace type in the start, use that type for the search but if they mention it later then update the search parameters(workspaceType) accordingly.\n\n"
		"When a user asks about workspaces:\n"
		"	- Acknowledge their request professionally\n"
		"	- Extract the following information and format as JSON: workspaceName, city, area, workspaceType (options: day pass, flexi desk, dedicated desk, private cabin), size, amenities (list), bundle (options: standard, silver, gold, platinum, platinum+), budget, rating, offeringType (options: day pass, flexi desk, dedicated desk, private cabin)\n"
		"	- If information is missing, set to null or empty values (0 for integer columns and [] for list columns)\n"
		"	- DO NOT include any specific workspace details or recommendations\n"
		"	- Extract the input parameters from the user message and format them as JSON.\n\n"
		"Understand important keywords:\n"
		"	- 'day pass' means a single day access\n"
		"	- 'flexi desk' means a flexible desk for a month\n"
		"	- 'dedicated desk' means a personal desk for a month\n"
		"	- 'private cabin' means a coworking space or workspace or office or private office or cabin or shared office for a month\n"
		"	- 'bundle' or 'category' refers to the pricing category (standard, silver, gold, platinum, platinum+)\n"
		"	- 'budget' refers to the maximum price they are willing to pay\n"
		"	- 'offerings' refers to the type of desk types (day pass, flexi desk, dedicated desk, private cabin) provided by the workspace\n\n"
		"If user mentions any words like 'office', 'coworking space', 'shared office', 'workspace', 'desk', 'cabin', 'private office', etc., consider it as a workspace search request unless they ask about the services provided - understand if the request is a question or a statement and then decide accordingly.\n\n"
		"If the user asks about workspaces, extract their requirements and respond with a friendly message acknowledging their request.\n"
		"Remember: The recommendation engine will add the actual workspace suggestions after your response.\n"
		"Also remember: Not all user messages will be about workspaces. If the user asks about something else, just have a friendly conversation with the knowledge provided to you.\n\n"
		"IMPORTANT: Maintain continuity with previous exchanges. If the user refers to something mentioned earlier, use that context in your response.\n\n"
		"IMPORTANT: Keep your responses concise and focused on the user's requirements. Avoid unnecessary details or explanations. And do NOT include recommendations in your response.\n\n"
		f"IMPORTANT: If user asks for filtering/sorting options (user_wants_filters={user_wants_filters}), mention that filtering options are available in your response and display the recommendations with the filtering options\n\n"
		f"User message: {user_message}\n"
		f"Chat history: {chat_history}\n"
	)

	contents = []
	
	contents.append({
		"role": "user",
		"parts": [{"text": system_prompt}]
	})

	
	contents.append({
		"role": "model",
		"parts": [{"text": "I understand. I'll help users with workspace searches by having friendly conversations, extracting their requirements, and letting the recommendation engine handle workspace suggestions. Also I will handle any follow-up questions about the workspaces recommended with the help of the chat history."}]
	})

	if chat_history:
		for msg in chat_history:
			role = "user" if msg.get("sender") == "user" else "model"
			text = msg.get("text", "").strip()
			if text:  
				contents.append({
					"role": role,
					"parts": [{"text": text}]
				})

	contents.append({
		"role": "user", 
		"parts": [{"text": user_message}]
	})

	payload = {"contents": contents}
	params = {"key": GEMINI_API_KEY}

	try:
		response = requests.post(url, headers=headers, params=params, json=payload, timeout=30)
		response.raise_for_status()
		gemini_reply = response.json()
		
		raw_reply = gemini_reply.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("text", "")
		
		print(f"Gemini API response: {raw_reply}") 

		if not raw_reply:
			return {"error": "Empty response from Gemini API"}

		lines = raw_reply.split('\n')
		cleaned_lines = []
		workspace_keywords = [
			'workspaceName:', 'coworking space:', 'Address:', 'location:', 'bundle:', 'budget:', 'Workspace Type:',
			'Amenities:', 'price:', 'Rating:', 'Seats available:', 'capacity:', 'size:', 'offeringType:',
			'visit:', 'book now:', 'contact:', 'city:', 'area:', 'Offerings:', 'workspaceType:', 'Category:', 'Link:',
			'workspace name', 'coworking space'
		]
		text = "here are some workspace recommendations for you:"

		for line in lines:
			line_lower = line.lower().strip()
			if any(keyword in line_lower for keyword in workspace_keywords):
				continue
			if text in line_lower:
				break
			if re.search(r'^\d+\.\s+[\w\s]+\(.*,.*\)', line.strip()):
				continue
			if re.search(r'\b\d+.*road|street|avenue|lane|sector\b', line_lower):
				continue
			cleaned_lines.append(line)
		
		reply_text = '\n'.join(cleaned_lines).strip()

	#	if len(reply_text.strip()) < 15:
	#		reply_text = "I understand your workspace requirements. Let me find the best options for you."

	except Exception as e:
		return {"error": f"Gemini API error: {str(e)}"}

	json_match = re.search(r'\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}', raw_reply)
	extracted = None
	
	if json_match:
		reply_text = reply_text.replace(json_match.group(0), '').strip()
		reply_text = re.sub(r'```json|```', '', reply_text).strip()
		try:
			extracted = json.loads(json_match.group(0))
			if not isinstance(extracted, dict):
				extracted = None
		except json.JSONDecodeError:
			extracted = None

	final_reply = reply_text

	# Add filter mention if user wants filters
	if user_wants_filters and extracted and (extracted.get("city") or extracted.get("workspaceType")):
		final_reply += "\n\nI'll include filtering options with the recommendations so you can sort and filter them by price, rating, and location."

	price_keywords = ["price", "cost", "rate", "charges"]
	offering_types = {
		"day pass": "DAY PASS",
		"flexi desk": "FLEXI DESK _MONTHLY",
		"dedicated desk": "DD_MONTHLY",
		"private cabin": "PC_MONTHLY"
	}

	if extracted and (extracted.get("offeringType") and extracted.get("workspaceName")):
		found_offering = str(extracted.get("offeringType") or "").strip().lower()
		workspace_name = str(extracted.get("workspaceName") or "").strip().lower()
		if found_offering not in offering_types:
			return {"reply": "I understand your workspace requirements, but I couldn't determine the workspace type. Please specify if you're looking for a day pass, flexi desk, dedicated desk, or private cabin."}
		
		df_temp = df.copy()
		res_row = df_temp[df_temp['Unboxed Coworking'].str.lower() == workspace_name]
		if res_row.empty:
			return {"reply": "I understand your workspace requirements, but I couldn't find the specified workspace. Please check the name and try again."}
		
		for key in res_row['Offering'].values[0].split(','):
			key = key.strip().lower()
			if key == found_offering:
				final_reply += f"\n\nI found the workspace '{workspace_name.title()}' with the offering type '{found_offering.title()}' has a price of ₹{res_row[offering_types[found_offering]].values[0]}."
				break

	if extracted and (extracted.get("city") or extracted.get("workspaceType") or extracted.get("area")):
		try:											 
			name = str(extracted.get("workspaceName") or "").strip().lower()
			raw_city = str(extracted.get("city") or "").strip().lower()
			city = city_alias_map.get(raw_city, raw_city)
			area_val = extracted.get("area")
			if isinstance(area_val, str):
				areas = [a.strip().lower() for a in re.split(r',|and', area_val) if a.strip()]
			elif isinstance(area_val, list):
				areas = [str(a).strip().lower() for a in area_val if str(a).strip()]
			else:
				areas = []

			workspace_type = str(extracted.get("workspaceType") or "").strip().lower()
			bundle = extracted.get("bundle")

			if isinstance(bundle, list):
				bundle = [str(b).strip().lower() for b in bundle if str(b).strip()]
			elif isinstance(bundle, str):
				bundle = [bundle.strip().lower()] if bundle.strip() else []
			else:
				bundle = []

			try:
				size = int(extracted.get("size") or 1)
				size = max(1, size)
			except (ValueError, TypeError):
				size = 1

			try:
				budget = float(extracted.get("budget") or 0)
				budget = max(0, budget)
			except (ValueError, TypeError):
				budget = 0
			try:
				rating = float(extracted.get("rating") or 0)
				rating = max(0, min(5, rating))  
			except (ValueError, TypeError):
				rating = 0

			user_amenities = extracted.get("amenities") or []
			if isinstance(user_amenities, list):
				user_amenities = [str(a).strip().lower() for a in user_amenities if str(a).strip()]
			else:
				user_amenities = []

			df_filtered = df.copy()

			if name and 'Unboxed Coworking' in df_filtered.columns:
				df_filtered = df_filtered[df_filtered['Unboxed Coworking'].str.lower() == name]

			if city and 'CITY' in df_filtered.columns:
				df_filtered = df_filtered[df_filtered['CITY'].str.lower() == city]

			if 'STATUS' in df_filtered.columns:
				df_filtered = df_filtered[df_filtered['STATUS'].str.lower() == 'live']

			if areas and 'AREA' in df_filtered.columns:
				df_filtered = df_filtered[df_filtered['AREA'].str.lower().isin(areas)]

			if 'seats_available' in df_filtered.columns:
				df_filtered = df_filtered[df_filtered['seats_available'] >= size]

			price_col_map = {
				'day pass': 'DAY PASS',
				'flexi desk': 'FLEXI DESK _MONTHLY',
				'dedicated desk': 'DD_MONTHLY',
				'private cabin': 'PC_MONTHLY'
			}
			price_col = price_col_map.get(workspace_type)

			if isinstance(bundle, str):
				bundle_list = [b.strip().lower() for b in bundle.split(',') if b.strip()]
			elif isinstance(bundle, list):
				bundle_list = [str(b).strip().lower() for b in bundle if str(b).strip()]
			else:
				bundle_list = []

			if bundle_list and 'CATEGORY AS PER PRICING' in df_filtered.columns:
				df_filtered = df_filtered[df_filtered['CATEGORY AS PER PRICING'].str.lower().isin(bundle_list)]

			if price_col and price_col in df_filtered.columns:
				df_filtered = df_filtered[df_filtered[price_col] > 0]
				if budget > 0:
					df_filtered = df_filtered[df_filtered[price_col] <= budget]

			if rating > 0 and 'avg_rating' in df_filtered.columns:
				df_filtered = df_filtered[df_filtered['avg_rating'] >= rating]

			if df_filtered.empty:
				recommendations_text = "\n\nSorry, I couldn't find any workspaces matching your criteria. You might want to try adjusting your requirements."
				final_reply += recommendations_text
				return {"reply": final_reply}

			# --- Feature similarity calculations (always use all available features) ---
			similarities_list = []
			weights = []
			# 1. Amenities similarity (cosine)
			amenities_data = []
			if 'AMENITIES' in df_filtered.columns:
				for amenities in df_filtered['AMENITIES']:
					if isinstance(amenities, list):
						amenities_data.append([str(a).strip().lower() for a in amenities])
					else:
						amenities_data.append([])
				if amenities_data and user_amenities:
					mlb = MultiLabelBinarizer()
					services_encoded = mlb.fit_transform(amenities_data)
					all_amenities = set(mlb.classes_)
					user_amenities_filtered = [a for a in user_amenities if a in all_amenities]
					if user_amenities_filtered:
						user_cat = mlb.transform([user_amenities_filtered])
						amenity_sim = cosine_similarity(user_cat, services_encoded)[0]
						similarities_list.append(amenity_sim)
						weights.append(2.0)
					else:
						similarities_list.append([0]*len(df_filtered))
						weights.append(2.0)
			# 2. Area match (binary)
			if areas and 'AREA' in df_filtered.columns:
				area_sim = df_filtered['AREA'].apply(lambda x: 1.0 if x in areas else 0.0).values
				similarities_list.append(area_sim)
				weights.append(1.0)
			# 3. Bundle match (binary)
			if bundle_list and 'CATEGORY AS PER PRICING' in df_filtered.columns:
				bundle_sim = df_filtered['CATEGORY AS PER PRICING'].apply(lambda x: 1.0 if x in bundle_list else 0.0).values
				similarities_list.append(bundle_sim)
				weights.append(1.0)
			# 4. Rating (normalized difference)
			if rating > 0 and 'avg_rating' in df_filtered.columns:
				max_rating = 5.0
				rating_sim = 1.0 - abs(df_filtered['avg_rating'] - rating) / max_rating
				similarities_list.append(rating_sim.values)
				weights.append(1.0)
			# 5. Price (normalized difference)
			if price_col and price_col in df_filtered.columns and budget > 0:
				max_price = max(df_filtered[price_col].max(), budget)
				price_sim = 1.0 - abs(df_filtered[price_col] - budget) / max_price
				similarities_list.append(price_sim.values)
				weights.append(1.0)
			# 6. Workspace type (binary)
			if workspace_type and 'Offering' in df_filtered.columns:
				ws_type_sim = df_filtered['Offering'].apply(lambda x: 1.0 if workspace_type in str(x).lower() else 0.0).values
				similarities_list.append(ws_type_sim)
				weights.append(1.0)
			# --- Combine similarities ---
			if similarities_list:
				import numpy as np
				similarities_arr = np.array(similarities_list)
				weighted_sim = np.average(similarities_arr, axis=0, weights=weights)
				df_filtered = df_filtered.copy()
				df_filtered['similarity_score'] = (weighted_sim * 100).round(2)
				high_similarity = df_filtered[df_filtered['similarity_score'] >= MIN_SIMILARITY_SCORE]
				if not high_similarity.empty:
					top_recommendations = high_similarity.sort_values(['similarity_score', 'avg_rating'], ascending=[False, False]).head(25)
				else:
					top_recommendations = df_filtered.sort_values('avg_rating', ascending=False).head(25)
			else:
				top_recommendations = df_filtered.sort_values('avg_rating', ascending=False).head(25)

			seen_workspaces = set()
			result = []
			
			for _, row in top_recommendations.iterrows():
				workspace_name =  str(row.get('Unboxed Coworking', '')).strip()
				workspace_address = str(row.get('ADDRESS', '')).strip()
				workspace_id = f"{workspace_name.lower()}_{workspace_address.lower()}"
				
				if workspace_id not in seen_workspaces and workspace_name:
					seen_workspaces.add(workspace_id)
					
					category_value = str(row.get('CATEGORY AS PER PRICING', '')).strip().title()
					
					price_value = ""
					if price_col and price_col in row:
						price_value = row.get(price_col, '')
					
					rec = {
						"name": workspace_name,
						"address": workspace_address,
						"workspace_type": workspace_type or "general",
						"city": str(row.get('CITY', '')).strip(),
						"area": str(row.get('AREA', '')).strip(),
						"amenities": row.get('AMENITIES', []) if isinstance(row.get('AMENITIES'), list) else [],
						"status": str(row.get('STATUS', '')).strip(),
						"seats_available": row.get('seats_available', ''),
						"rating": row.get('avg_rating', ''),
						"category": category_value,
						"price": price_value,
						"offerings": str(row.get('Offering', '')),
						"similarity_score": row.get('similarity_score', 0)
					}
					result.append(rec)

			if result:
				recommendations_text = "\n\nHere are some workspace recommendations for you:\n"
				for idx, rec in enumerate(result, 1):
					recommendations_text += (
						f"\n{idx}. {rec['name'].title()}"
					)
					if rec['area']:
						recommendations_text += f" (Area: {rec['area'].title()})"
					"""
					if rec['area'] and rec['city']:
						recommendations_text += f" ({rec['area']}, {rec['city']})"
					elif rec['city']:
						recommendations_text += f" ({rec['city']})"
					"""
					recommendations_text += f"\n   Address: {rec['address']}"

					recommendations_text += f"\n   Workspace Type: {rec['workspace_type'].title()}"

					recommendations_text += f"\n   Offerings: {rec['offerings']}"

					if rec['amenities']:
						amenities_str = ', '.join(rec['amenities'])  
						recommendations_text += f"\n   Amenities: {amenities_str}"
					
					if rec['seats_available']:
						recommendations_text += f"\n   Seats Available: {rec['seats_available']}"
					
					if rec['rating']:
						recommendations_text += f"\n   Rating: {rec['rating']}"
					
					if rec['category']:
						recommendations_text += f"\n   Category: {rec['category']}"
					
					if rec['price']:
						recommendations_text += f"\n   Price: ₹{rec['price']}"
					
					if rec['similarity_score'] > 75:
						recommendations_text += f"\n   Similarity Score: {rec['similarity_score']}% "

					workspace_slug = rec['name'].lower().replace(' ', '-').replace('&', 'and')
					city_slug = rec['city'].lower().replace(' ', '-')
					if rec['workspace_type'].lower() == "private cabin":
						workspace_type_slug = "private-office-cabins"
					else:
						workspace_type_slug = rec['workspace_type'].replace(' ', '-')
					
					recommendations_text += f"\n   Link: [View Details](https://www.stylework.city/{workspace_type_slug}/{city_slug}/{workspace_slug})\n"
				
				final_reply += recommendations_text
			else:
				final_reply += "\n\nSorry, I couldn't find any workspaces matching your specific criteria. You might want to try adjusting your requirements."
		except Exception as e:
			print(f"Error in recommendation engine: {str(e)}")
			final_reply += "\n\nI understand your requirements, but encountered an issue while searching. Please try again."
	
	session.add_assistant_message({
		"type": "assistant",
		"content": final_reply,
	})
	# Get the last message (assistant) to extract its timestamp
	last_msg = session.get_messages()[-1] if session.get_messages() else None
	timestamp = last_msg.get("timestamp") if last_msg else None

	return {"reply": final_reply, "recommendations: ": result, "timestamp": timestamp}

	return {
		"reply": final_reply,
		"session_id": session.session_id
	}